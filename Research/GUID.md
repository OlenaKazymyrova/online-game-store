
## Guid research

Note: this research was created with help of chatGPT [link](https://chatgpt.com/s/dr_683d8b0ceee08191a448a177b272a88b)

## Structure and versions
<details>
A GUID is 128 bits (16 bytes) long and is usually displayed as 32 hexadecimal characters (0–9, A–F)
separated by hyphens. The standard format is 8-4-4-4-12 characters (36 characters total, including
hyphens). For example:

```
550e8400-e29b-41d4-a716-446655440000
              ^M   ^N
```

Each part represents a portion of the 128-bit value. In the above example (and as shown in the
diagram), the “M” digit (13th character) is the version field, and the “N” digit (17th character) is the
variant field . (In this example the “4” in position M means it’s a version 4 GUID, and the “a” in
position N means it follows the RFC 4122 variant.)
The bits of a GUID are defined by the version. For instance, a version 1 GUID includes a timestamp and
MAC address in the high-order bits, whereas a version 4 GUID has those bits set randomly. The diagram
above highlights where the version and variant bits live . No matter the version, the size is fixed at
128 bits, and in databases GUIDs are stored in 16 bytes (often in binary form) internally for efficiency.
GUIDs can be generated by libraries or database functions in many platforms. For example, SQL Server
has the `NEWID()` (random GUID) and `NEWSEQUENTIALID()` (time-sequential GUID) functions.
`PostgreSQL` can generate GUIDs with the `uuid-ossp` or `pgcrypto` extensions
(`uuid_generate_v4()`, `gen_random_uuid()` , etc.). In all cases, the algorithm sets the timestamp,
random, or hash bits according to RFC 4122 rules
</details>


## Comparison and further dive-in
<details>
<summary>GUIDs vs. Auto-Increment Keys: Comparison</summary>

GUIDs and auto-increment (identity/serial) integers serve the same basic purpose (row identifiers) but
have different properties:

1. Uniqueness Scope: A GUID is unique across tables, databases, and servers by design. In
contrast, an auto-increment ID (INT) is only unique within a single table in one database. This
means GUIDs allow easy merging of records from different databases without collision,
whereas combining tables with INT IDs may require remapping or conflicts.
2. Generation Location: GUIDs can be generated anywhere (client side, middleware, or any node)
without a round-trip to the database . This is very useful for distributed or offline scenarios.
Auto-increment IDs require contacting the database (or a sequence generator) to allocate the
next value, which can be a bottleneck or require coordination.
3. Predictability/Privacy: Sequential INTs reveal order and scale (e.g. one can guess how many
orders were placed by looking at the highest ID). GUIDs appear random (especially v4) and do
not leak such information . This can be a privacy/security advantage if you expose IDs
externally.
4. Size and Storage: A GUID is 16 bytes, whereas a typical INT is 4 bytes (or BIGINT is 8 bytes). Thus
GUIDs consume more storage. GUID is 4 times larger than the
traditional 4-byte index value, which has serious storage and performance implications.
Larger keys mean larger indexes and more I/O.
5. Index Performance: Because GUIDs are larger and (often) random, using them as a clustered
primary key can scatter inserts across the index, causing page splits and fragmentation .
By contrast, an identity (INT) key is sequential, which clusters inserts at the end of the table and
is cache-friendly . As one SQL Server expert notes, a non-sequential GUID “can be a horribly
bad choice – primarily because of the fragmentation” it creates .
6. Join/Query Performance: Joins and index lookups on integers are faster due to smaller key size.
GUIDs can be very inefficient in join operations and require
“more pages” during queries because they’re wider than ints. `PostgreSQL` joins on UUID vs
BIGINT likewise involve comparing larger values, though in many simple PK lookups the
difference may be minor.
7. Replication and Merging: Some database features (replication, merging, sync) actually require
GUIDs or similar globally unique keys. In replicated SQL Server setups, a `UNIQUEIDENTIFIER`
column is commonly used to ensure no key collisions across nodes

</details>


<details>
<summary>Common Use Cases for GUIDs</summary>

GUIDs are especially useful in scenarios that require uniqueness or decentralization of ID generation:
1. Distributed Systems / Sharding: In microservices or distributed databases, multiple nodes may
need to create new records independently. GUIDs allow each node to generate unique IDs
without contacting a central server. For example, a multi-master database or horizontally
sharded system can use GUIDs for primary keys so that merged datasets never conflict .
2. Offline or Mobile Sync: When clients (like mobile apps) work offline and later sync data, having
a GUID allows the client to assign a unique ID without waiting for the server. One DBA described
a hybrid approach: each mobile device generated both an auto-increment ID and a GUID locally;
upon sync, the GUID ensured no conflict with other devices . Similarly, Internet-of-Things
systems often use GUIDs for sensor IDs generated at the device.
3. Merging Data: If you periodically merge or import data from different sources (e.g. importing
customer records from another system), GUIDs make it simple because you don’t have to
reconcile overlapping INT keys.
Security / Obscuring Internal IDs: GUIDs are hard to guess or enumerate. For example, if you
expose order IDs in a public API, using GUIDs prevents attackers from easily iterating over
sequential IDs to scrape data. While not foolproof, GUIDs add a layer of obscurity.
4. Logging and Correlation IDs: In distributed applications, it’s common to tag each request or
transaction with a “correlation ID” for tracing across services. These correlation IDs are often
GUID/UUIDs to ensure uniqueness and ease generation. As one expert notes, including a unique
correlation ID in every log and message lets you group all logs for a given request across many
microservices . GUIDs are frequently used for this purpose (though any unique string would
work).
5. Database Keys for External Entities: In systems where IDs must be globally unique (like COM
component IDs, GUIDs used by Windows, or any cross-system interface), GUIDs are the natural
choice. Many Microsoft APIs and registries still use GUIDs as stable identifiers.
- **Summary:** In short, use GUIDs when uniqueness across boundaries or offline generation matters . If those
needs don’t exist, a simpler INT may suffice.

</details>




## Drawbacks and Limitations of GUIDs
<details>
<summary>SQL Server Considerations</summary>

1. Size Overhead: A SQL Server unique identifier is 16 bytes (128 bits) , twice the size of a
BIGINT and four times an INT. Larger keys mean larger indexes (taking more pages) and more I/
O. This directly slows searches and joins.
2. Fragmentation (Clustered Index): The default primary key index in SQL Server is clustered. If
you make a random GUID (`NEWID()`) the clustering key, each new row is inserted into a random
part of the table, causing page splits and fragmentation . One DBA explains that random
GUID inserts force SQL Server to frequently move data between pages, severely impacting insert
throughput and scans .
3. Page Splits and I/O: Random inserts also hurt caching. If all inserts land at the end of an INT
index, those pages are likely in memory. Random inserts mean most cache misses, causing extra
disk I/O . This also increases write amplification: SQL Server will perform more full page
writes (FPWs) and flushes, hurting performance.
4. Clustered GUID Solutions: To mitigate these issues, SQL Server offers `NEWSEQUENTIALID()`
which generates GUIDs that increase roughly over time. Using a sequential GUID as a clustered
key clusters inserts at the end, similar to an INT . However, even sequential GUIDs are
only sequential per SQL Server instance startup , so reboots can break strict ordering.
5. Index Size and Joins: Because GUIDs are wide (16 bytes) vs INT (4 bytes), each index entry is
larger and joins must compare bigger values. Microsoft’s SQL documentation warns that GUIDs
“are a lot wider than an integer value” and “inefficient in join operations” . In practice, a join
on GUIDs can use roughly twice as much memory and CPU as on integers.
6. Debugging Difficulty: Human-readability is a minor issue: queries with GUIDs in WHERE clauses
are cumbersome to write/debug compared to small integers .
7. Fragmentation Accumulates: Over time, a heavily fragmented GUID-based index may require
frequent rebuilding. While fragmentation alone doesn’t always cripple performance, in practice it
raises maintenance needs .
- **Summary for SQL Server:** random GUID primary keys cause index fragmentation and bloat. If you
must use GUIDs, prefer them as non-clustered keys or use sequential GUIDs for clustered keys
</details>

<details>
<summary>PostgreSQL Considerations</summary>

1. Size Overhead: PostgreSQL’s uuid type is also 16 bytes. Like SQL Server, this means larger
indexes compared to 4-byte INT or 8-byte BIGINT. Larger index pages mean more cache usage
and slightly slower scans. In a join of many rows, the extra bytes can add up. In one benchmark,
UUID-based joins were only modestly slower than BIGINT joins, but the difference grew with
table size .
2. Loss of Locality: A major issue with random UUIDs in Postgres is loss of temporal locality. When
using a random UUID (v4) as a primary key, new rows are scattered across the index. A blog post
shows that “UUIDs lose any correlation between insert order and ID order” . In practical
terms, fetching recently-inserted rows requires touching random index pages, versus sequential
IDs which keep new rows on a few pages. This hurts cache efficiency for “recent data” queries.
3. Index-Only Scan Penalty: Because of the above, index-only scans perform worse. The visibility
map (used for index-only scans) covers blocks of pages, and a sequential key often means nearby
IDs share the same visibility map page. For random UUIDs, only ~1 in 7 recent rows share a page
, forcing many extra buffer visits. In a 10-million-row test, scanning a UUID index triggered
~8.5 million additional buffer hits for visibility checks . In short, random UUID PKs prevent
Postgres from taking full advantage of index-only scans.
4. Write Amplification and WAL: Random inserts also cause more random writes and WAL (Write-
Ahead Logging) activity. An experienced DBA notes that inserting many random UUIDs can flood WAL with full-page writes (FPWs), generating vastly more log traffic than sequential inserts .
This can slow inserts and replication.
5. Bloat and Vacuuming: Over time, random insert patterns can lead to index bloat and require
more frequent vacuuming or reindexing. The fragmentation is not the same as in SQL Server’s
clustered index (Postgres doesn’t have a clustered index in the same way), but it still means
indexes grow less compactly.
6. Version Considerations: The upcoming UUIDv7 (time-ordered) and ULID formats address many
of these drawbacks by making UUIDs roughly chronological. Until these are available, some use
tricks like prefixing a timestamp or using uuid_generate_v1() (time/MAC) to get better
ordering. In practice, if you need GUIDs in Postgres and care about inserts, consider a **time-based**
UUID. As one expert notes, “using random is typically the worst thing you can do for
locality, so if you want to use UUIDs, try to use a sequential variant (UUID v7 is a good
option)”
</details>

